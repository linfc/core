main(member) ::= <<
$member; separator="\n\n"$
>>

pickler(member) ::= <<
object Pickler {
  import upickle.Implicits._
  $member; separator="\n"$
}
>>

name(class) ::= <<
private val $class$Name = classOf[$class$].getName
>>

leaf(class, wfield, rfield) ::= <<
implicit val $class$Pickler = new ReadWriter[$class$](
  o => Js.Object(Seq(("type", writeJs($class$Name))$if(wfield)$, $wfield; separator=", "$$endif$)),
  { case Js.Object(s) =>
      val m = Map(s : _*) 
      $class$($rfield; separator=", "$) 
  }
)
>>

leafWriteField(name) ::= <<
("$name$", writeJs(o.$name$))
>>

leafReadField(type, name) ::= <<
readJs[$type$](m("$name$"))
>>

root(class, wfield, rfield) ::= <<
implicit val aPickler = new ReadWriter[A](
  _ match {
    $wfield; separator="\n"$
  },
  {
    case o @ Js.Object(s) =>
      readJs[String](s.find(_._1 == "type").get._2) match {
        $rfield; separator="\n"$
      }
  }
)
>>

rootWriteField(class) ::= <<
case o : $class$ => $class$Pickler.write(o)
>>

rootReadField(class) ::= <<
case `$class$Name` => $class$Pickler.read(o)
>>

leafPy(class, field, fieldAssign) ::= <<
def $class$($field; separator=", "$):
  o = {}
  $fieldAssign; separator="\n"$
  o['type'] = "$class$"
  return json.dumps(o)
>>

leafPyAssign(name) ::= <<
o['$name$'] = $name$
>>